<templateSet group="Kotlin">
  <template name="my_fun_EventBusMainThread" value="@Subscribe&#10;fun onEventMainThread(  event : $varType$ ) {&#10;    &#10;}" description="主线程中接收Event事件的方法" toReformat="false" toShortenFQNames="true">
    <variable name="varType" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="myThreeBodyIf" value="var $getResult$: Boolean = $sourceObject$.takeIf { $sourceObject$$ifStateMent$/* 条件的判断语句 */ }//三元运算符//var sourceObject: srcType = srcType()&#10;    ?.let { $true$; return@let true }/* 当符合正确条件时，执行的语句 */&#10;    ?: false.let { $false$;return@let false }/* 当不符合正确条件时，执行的语句 */" description="自动生成的自制三元运算符" toReformat="false" toShortenFQNames="true">
    <variable name="getResult" expression="" defaultValue="&quot;result&quot;" alwaysStopAt="true" />
    <variable name="sourceObject" expression="" defaultValue="&quot;any&quot;" alwaysStopAt="true" />
    <variable name="ifStateMent" expression="" defaultValue="&quot;.equals(\&quot;A Magic\&quot;)&quot;" alwaysStopAt="true" />
    <variable name="true" expression="" defaultValue="&quot;TODO(\&quot;true 黄金色TODO\&quot;)&quot;" alwaysStopAt="true" />
    <variable name="false" expression="" defaultValue="&quot;TODO(\&quot;false 黄金色TODO\&quot;)&quot;" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="myRxModule_Fun" value="    fun readyCreateGroup(&#10;            group_name: String, //群名称&#10;            category_id: String, //&#9;群类别&#10;            type: String, //&#9;群类类 1私有群 0公开群&#10;            user_id: String, //&#9;用户id&#10;            latitude: String, //&#9;纬度&#10;            longitude: String, //&#9;经度&#10;            address: String, //城市&#10;            laravel_session: String&#10;    ): Observable&lt;CreateGroupPojo&gt; {&#10;        return Observable.create&lt;CreateGroupPojo&gt; {&#10;            BaseRetroifit.geek().createGroup(group_name,&#10;                    category_id,&#10;                    type,&#10;                    user_id,&#10;                    latitude,&#10;                    longitude,&#10;                    address,&#10;                    laravel_session&#10;            ).enqueue(object : MyRetrofitCallBack&lt;CreateGroupPojo&gt;() {&#10;                override fun onAchieve(call: Call&lt;CreateGroupPojo&gt;, response: Response&lt;CreateGroupPojo&gt;) {&#10;                    it.onNext(response.body())&#10;                }&#10;            })&#10;        }&#10;    }" description="自动生成——大段的一般化请求方法" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="myRxModule_Fun_Files" value="    fun readyStartMatch(&#10;            user_id: String, //用户id&#10;            title: String, //比赛名称&#10;            description: String, //&#9;contest说明&#10;            video_time: String, //作品时间长度，可选值&#10;            address: String, //&#9;城市&#10;            group_id: String, //群id&#10;            latitude: String, //纬度&#10;            longitude: String, //经度&#10;            video: File, //&#9;视频&#10;            img: File//&#9;视频截图&#10;    ): Observable&lt;HostMatchPojo&gt; {&#10;        val typeText = MediaType.parse(&quot;text/plain&quot;)//文字&#10;        val typeStream = MediaType.parse(&quot;application/octet-stream&quot;)//二进制流&#10;&#10;        val userIdBody = RequestBody.create(typeText, user_id)&#10;        val titleBody = RequestBody.create(typeText, title)&#10;        val descriptionBody = RequestBody.create(typeText, description)&#10;        val videoTimeBody = RequestBody.create(typeText, video_time)&#10;        val addressBody = RequestBody.create(typeText, address)&#10;        val groupIdBody = RequestBody.create(typeText, group_id)&#10;        val latitudeBody = RequestBody.create(typeText, latitude)&#10;        val longitudeBody = RequestBody.create(typeText, longitude)&#10;&#10;        val videoBody = RequestBody.create(typeStream, video)&#10;        val imgBody = RequestBody.create(typeStream, img)&#10;        val videoPart = MultipartBody.Part.createFormData(&quot;video&quot;, video.name, videoBody)&#10;        val imgPart = MultipartBody.Part.createFormData(&quot;img&quot;, img.name, imgBody)&#10;&#10;        return Observable.create&lt;HostMatchPojo&gt; {&#10;            BaseRetroifit.geek().startMatch(&#10;                    userIdBody,&#10;                    titleBody,&#10;                    descriptionBody,&#10;                    videoTimeBody,&#10;                    addressBody,&#10;                    groupIdBody,&#10;                    latitudeBody,&#10;                    longitudeBody,&#10;                    MySpUtil.loadSessionValue(),&#10;                    videoPart,&#10;                    imgPart&#10;            ).enqueue(object : MyRetrofitCallBack&lt;HostMatchPojo&gt;() {&#10;                override fun onAchieve(call: Call&lt;HostMatchPojo&gt;, response: Response&lt;HostMatchPojo&gt;) {&#10;                    it.onNext(response.body())&#10;                }&#10;            })&#10;        }&#10;    }&#10;&#10;" description="自动生成，带文件上传的  RxModule请求方法" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="myMVP_presenter_Fun" value="    fun doCreateGroup(&#10;            group_name: String, //群名称&#10;            category_id: String, //&#9;群类别&#10;            type: String, //&#9;群类类 1私有群 0公开群&#10;            user_id: String, //&#9;用户id&#10;            latitude: String, //&#9;纬度&#10;            longitude: String, //&#9;经度&#10;            address: String, //城市&#10;            laravel_session: String&#10;    ) {&#10;        module.createGroup(&#10;                group_name,&#10;                category_id,&#10;                type,&#10;                user_id,&#10;                latitude,&#10;                longitude,&#10;                address,&#10;                laravel_session&#10;        ).subscribe(object : MyRxConsumer&lt;CreateGroupPojo&gt;() {&#10;            override fun action(result: CreateGroupPojo) {&#10;                view.afterCreateGroup(result)&#10;            }&#10;        })&#10;    }&#10;" description="自动生成  Presenter的处理的模板方法" toReformat="false" toShortenFQNames="true" deactivated="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="myMVP_view_abstract_Fun" value="&#10;    fun afterCreateGroup(result: CreateGroupPojo)&#10;    " description="自动生成————在P和M都处理完后，View的操作" toReformat="false" toShortenFQNames="true" deactivated="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="mySlimAdapter_Simple_style" value="        val adapter = SlimAdapter.create().register(R.layout.item_main_top, object: SlimInjector&lt;String&gt;{&#10;            override fun onInject( data:String? , injector:IViewInjector&lt;out IViewInjector&lt;*&gt;&gt;?){&#10;            &#10;            }&#10;        })&#10;        adapter.updateData(pojoList)&#10;        rv_top.let {&#10;            it.layoutManager = LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false)&#10;            it.adapter = adapter&#10;            it.adapter.notifyDataSetChanged()&#10;        }" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="myAll_mvp_ver_2.0" value="&#10;        //RxModule方法&#10;        fun ready$FunName$(&#10;                  //Parameters&#10;            )&#10;            : Observable&lt;$PojoType$&gt; &#10;            =&#10;            handleM({selfConnect.$ApiName$(           )},&#10;                    {TLog.l(&quot;&quot;)}&#10;            )&#10;    &#10;    &#10;        //Presenter方法&#10;        fun do$FunName$(&#10;               //Parameters&#10;            ) &#10;            =&#10;            handleP({ module.ready$FunName$(        )  },                      //从M来&#10;                    { view.after$FunName$(     it     ) })                     //到V去&#10;            &#10;        &#10;    &#10;    &#10;    &#10;    &#10;        //View方法&#10;        fun after$FunName$(result: $PojoType$ )&#10;        &#10;        &#10;        &#10;        &#10;        &#10;        &#10;        //activity方法&#10;        override fun after$FunName$(result: $PojoType$) {&#10;        &#10;        }&#10;        &#10;        &#10;        &#10;        &#10;        " description="自动生成一键所有代码，创新版本2.0模式" toReformat="false" toShortenFQNames="true" deactivated="true">
    <variable name="FunName" expression="" defaultValue="&quot;Fun&quot;" alwaysStopAt="true" />
    <variable name="PojoType" expression="" defaultValue="&quot;PojoType&quot;" alwaysStopAt="true" />
    <variable name="ApiName" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="myAll_mvp_ver_3.0" value="&#10;        //（M层IO通讯）&#10;        fun ready$FunName$(&#10;                  //param_list&#10;        ): Observable&lt;$PojoType$&gt; =&#10;            mvp_Module_Enclosure(&#10;                    { selfConnect?.$connection_api_method$() },                                     //在这里，请求IO网络数据。&#10;                    { success_response -&gt;&#10;                        //ext_log(&quot;在此，经过了进入Presenter前的最后一道关卡。&quot;)      //拿到数据而进入Presenter前，最后一道关卡。&#10;                    },&#10;                    { beyond_body_pojo -&gt;&#10;                        ext_log(&quot;对于异常情况的Module层手动处理。&quot;)                //处理异常情况。（若无异常和错误，则进入Presenter）&#10;                    },&#10;                    { fail_call, fail_throwable -&gt;&#10;                        ext_log(&quot;对于错误情况的Module层手动处理。&quot;)                //处理错误的情况。（若无异常和错误，则进入Presenter）&#10;                    },&#10;                    true                                                        //是否显示ProgressBar的加载Dialog&#10;            )&#10;    &#10;    &#10;        //（P层IO闭包）&#10;        //IO方法介绍：&#10;        fun do$FunName$(&#10;               //param_list&#10;        )=&#10;        //专门处理 I/O 耗时操作。（网络请求、数据存储等）&#10;            activity.apply {&#10;                mvp_Presenter_IO_Enclosure(&#10;                        {&#10;                            module.ready$FunName$()                                              //在这里，首先进行调用Module层的网络访问。&#10;                        },&#10;                        { resultPojo -&gt;&#10;                            activity.apply {&#10;                                //ext_log(&quot;这是Module层IO通讯的回调。在这里执行一次。&quot;)           //在这里，是从Module层，得到了成功回调。对回调进行完整处理。&#10;                            }&#10;                        },&#10;                        { resultPojo -&gt;&#10;                            mvpView.after$FunName$(resultPojo, &quot;IO环节，正常完成&quot;)                  //在这里，是Presenter层执行完毕，分发到View层。&#10;                        }&#10;                )&#10;            }&#10;            &#10;&#10;        //（P层UI闭包）&#10;        //UI方法介绍：&#10;        fun do$FunName$(&#10;                //param_list&#10;        )=&#10;        //专门处理，关于UI的动作和操作。&#10;            activity.apply {&#10;                mvp_Presenter_Pure_UI_Enclosure(&#10;                        {&#10;                            //ext_log(&quot;前半部分的操作。&quot;)&#10;                        },&#10;                        {&#10;                            //ext_log(&quot;后半部分的操作。&quot;)&#10;                        },&#10;                        { mvpView.after$FunName$(null, &quot;传递给MvpActivity的文本描述内容&quot;) }&#10;                )&#10;            }&#10;&#10;        &#10;    &#10;    &#10;    &#10;    &#10;        //（V层UI反馈：接口）&#10;        fun after$FunName$(result: $PojoType$? , infoMsg : String  )&#10;        &#10;        &#10;        &#10;        &#10;        &#10;        &#10;        //（V层UI反馈：实现）&#10;        override fun after$FunName$(result: $PojoType$? , infoMsg : String) = let { ext_log(&quot;说明词&quot;) }&#10;&#10;&#10;" description="M、V、P、AC方法，3.0版本一键模板" toReformat="false" toShortenFQNames="true">
    <variable name="FunName" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="PojoType" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="connection_api_method" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="my_websocket_callback_event_listener" value="    var pre_kline_sub_result = &quot;&quot;                                                                   //最近一次K线订阅所返回的数据。&#10;    @Subscribe(threadMode = ThreadMode.MAIN)&#10;    fun onKLine_SubResult(event: WS_KLine_SubResult_Pojo) {&#10;        val my_ch = &quot;market.${ws_market_type_special_code.toLowerCase()}.kline.$ws_kline_time_sharing&quot;&#10;        if (my_ch.equals(event.ch)) {&#10;            //                                                                                      ext_log(&quot;符合了更新条件。&quot;)&#10;            this.presenter.doShowKLineChartView(event.tick)&#10;        } else {&#10;            //                                                                                      ext_log(&quot;不符合更新条件。&quot;)&#10;            //                                                                                      ext_log(&quot;my_ch：$my_ch。event.ch：${event.ch}&quot;)&#10;        }&#10;    }&#10;" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="my_fragment_lifecycler_schedule_task_PageFragment" value="    override fun setUserVisibleHint(isVisibleToUser: Boolean) {                                                     //TODO 处理，同一个ViewPager的情况下，当前Fragment显示或不显示。（当ViewPager整个跳转到其它的Fragment时，仍然无解。）&#10;        val isChangingState = (isVisibleToUser != getUserVisibleHint())                         //是否正在更改可见的生命周期。&#10;        super.setUserVisibleHint(isVisibleToUser)&#10;        val is_now_fragment_Visible_to_User = getUserVisibleHint()&#10;        if (isChangingState &amp;&amp; is_now_fragment_Visible_to_User) {                                              //正在改变，且改变后是可见的状态。&#10;            ext_log(&quot;BuyFragment的计时器被打开了。&quot;)&#10;            this.presenter.doStartScheduleTask()&#10;        } else {&#10;            ext_log(&quot;BuyFragment的计时器被关闭了。&quot;)&#10;            this.presenter.doStopScheduleTask()&#10;        }&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        ext_log(&quot;页面恢复了。&quot;)&#10;        this.presenter.doStartScheduleTask()&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        ext_log(&quot;页面暂停了。&quot;)&#10;        this.presenter.doStopScheduleTask()&#10;    }" description="" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="myAll_mvp_ver_3.0_http&amp;ws" value="//变量1：统一方法名&#10;//变量2：HTTP请求，返回的POJO类型&#10;//变量3：HTTP请求，调用的API接口名。&#10;//变量4：订阅的API_TYPE名。&#10;//变量5：暂时不需要特别指定Ws的返回Pojo类型，给个错误的类型值————&gt;以报警警惕！。&#10;//变量6：View层的实现的中文描述词。&#10;&#10;    //0.发起HTTP请求，获取HTTP首次更新的数据。【$function_describe$】&#10;    fun readyUpdate$FunName$_byHTTP(&#10;                //param_list&#10;    ): Observable&lt;$PojoType$&gt; =&#10;        mvp_Module_Enclosure(&#10;                { selfConnect?.$connection_api_method$   },                                     //在这里，请求IO网络数据。&#10;                { success_response -&gt;&#10;                    //ext_log(&quot;在此，经过了进入Presenter前的最后一道关卡。&quot;)      //拿到数据而进入Presenter前，最后一道关卡。&#10;                },&#10;                { beyond_body_pojo -&gt;&#10;                    ext_log(&quot;对于异常情况的Module层手动处理。&quot;)                //处理异常情况。（若无异常和错误，则进入Presenter）&#10;                },&#10;                { fail_call, fail_throwable -&gt;&#10;                    ext_log(&quot;对于错误情况的Module层手动处理。&quot;)                //处理错误的情况。（若无异常和错误，则进入Presenter）&#10;                },&#10;                true                                                        //是否显示ProgressBar的加载Dialog&#10;        )&#10;&#10;    //1.先用HTTP去获取第一次数据，进行快速的首次更新。【$function_describe$】&#10;    fun doUpdate$FunName$_byHTTP() =&#10;            fragment.apply {&#10;                mvp_Presenter_IO_Enclosure(&#10;                        {&#10;                            module.readyUpdate$FunName$_byHTTP()&#10;                        },&#10;                        { resultPojo -&gt;&#10;                            fragment.apply {&#10;                                this.presenter.doUpdate$FunName$_inLocalView()&#10;                            }&#10;                        },&#10;                        { resultPojo -&gt;&#10;                            mvpView.afterUpdate$FunName$_byHTTP(resultPojo, &quot;IO环节，正常完成&quot;)                  //在这里，是Presenter层执行完毕，分发到View层。&#10;                        }&#10;                )&#10;            }&#10;&#10;    //2.开启WebSocket，进行长期的低功耗订阅更新。【$function_describe$】&#10;    fun doUpdate$FunName$_byWS() =&#10;    //专门处理，关于UI的动作和操作。&#10;            fragment.apply {&#10;                mvp_Presenter_Pure_UI_Enclosure(&#10;                        {&#10;                            //发起订阅工作的请求。&#10;                            WsMarketClient.communication( $WS_API_TYPE$ , &quot;————————————————————你的参数一&quot;, &#10;                            &quot;————————————————————————你的参数二&quot;, fragment.hashCode())&#10;                        },&#10;                        {&#10;                            //ext_log(&quot;后半部分的操作。&quot;)&#10;                        },&#10;                        { mvpView.afterUpdate$FunName$_byWS(null, &quot;传递给MvpActivity的文本描述内容&quot;) }&#10;                )&#10;            }&#10;&#10;    //3.统一处理HTTP和WebSocket的返回数据，用数据进行视图更新。【$function_describe$】&#10;    fun doUpdate$FunName$_inLocalView(&#10;           &#10;    ) =&#10;    //专门处理，关于UI的动作和操作。&#10;            fragment.apply {&#10;                mvp_Presenter_Pure_UI_Enclosure(&#10;                        {&#10;                            //&#10;                            //本地的视图更新操作。&#10;                            //&#10;                        },&#10;                        {&#10;                            //ext_log(&quot;后半部分的操作。&quot;)&#10;                        },&#10;                        { mvpView.afterUpdate$FunName$_inLocalView(null, &quot;传递给MvpActivity的文本描述内容&quot;) }&#10;                )&#10;            }&#10;&#10;&#10;    //（V层UI反馈：接口）&#10;    fun afterUpdate$FunName$_byHTTP(result: $PojoType$?, infoMsg: String)&#10;&#10;    //（V层UI反馈：接口）&#10;    fun afterUpdate$FunName$_byWS(result: $PojoType$?, infoMsg: String)&#10;&#10;    //（V层UI反馈：接口）&#10;    fun afterUpdate$FunName$_inLocalView(result: $PojoType$?, infoMsg: String)&#10;&#10;    //（V层UI反馈：实现）&#10;    override fun afterUpdate$FunName$_byHTTP(result: $PojoType$?, infoMsg: String) = let { ext_log(&quot;在这里，先用HTTP获取【$function_describe$】。&quot;) }&#10;&#10;    //（V层UI反馈：实现）&#10;    override fun afterUpdate$FunName$_byWS(result: $PojoType$?, infoMsg: String) = let { ext_log(&quot;在这里，然后用WS订阅【$function_describe$】。&quot;) }&#10;&#10;    //（V层UI反馈：实现）&#10;    override fun afterUpdate$FunName$_inLocalView(result: $PojoType$?, infoMsg: String) = let { ext_log(&quot;在这里，统一处理了HTTP和WS的【$function_describe$】的视图处理。&quot;) }&#10;&#10;&#10;&#10;    @Subscribe(threadMode = ThreadMode.MAIN)&#10;    fun onUpdate$FunName$_WsSub_Result(event: 需要你的WebSocket返回类型 ) {                                         //HTTP返回的Pojo类，和Ws返回的Pojo类，可能会是两个不同的类型。但是两者有部分交集。&#10;        if (false == event.isInCache) {&#10;            val my_ch = &quot;——————————————填入你的拼接值——————————&quot;&#10;            if (my_ch == event.ch) {&#10;                this.presenter.doUpdate$FunName$_inLocalView(event.markets)&#10;                ext_log(&quot;此处，已经进行更新。发送的ch为${my_ch}，收到的ch为${event.ch}&quot;)&#10;            } else {&#10;                ext_log(&quot;此处，无法继续更新。发送的ch为${my_ch}，收到的ch为${event.ch}&quot;)&#10;            }&#10;        } else {&#10;            ext_log(&quot;此时，进入了缓存的${event.ch}路段。&quot;)&#10;        }&#10;    }" description="" toReformat="false" toShortenFQNames="true">
    <variable name="function_describe" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="FunName" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="PojoType" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="connection_api_method" expression="" defaultValue="" alwaysStopAt="true" />
    <variable name="WS_API_TYPE" expression="" defaultValue="" alwaysStopAt="true" />
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
</templateSet>